from ecdsa import ellipticcurve, numbertheory, util
from random import SystemRandom
import hashlib
from math import gcd

# 定义椭圆曲线参数
p = 918248074293461736852778669895660415691020927504244829732938533329277191456803113135776902381255711069749435232844412132152150688669383695561156810350243956811593296132421044786803600246260465810306614250806463384654108197096737170998175863388871008934337080814422554952611212195140753892819449465591066908854566752857114962875396556140193277982118398569623855332066176419816344880267199406744155134344583981522048455938422873966140062896157764408651052595077078269180025316622141168294874484451914344903885925315244965693775123192097930158931530029622825694621875388950949975241624828125800802137362908414619880852796838957406829284268203057968087887785356610453856642962895678482074727773529157491796997514049082757065208297584714260117490747850680953846742530577352459055414126832217510655702965275071192089806964406242852157
a = 87425770561190618633288232353256495656281438408946725202136726983601884085917
b = 107879772066707091306779801409109036008421651378615140327877558014536331974777
Gx = 34031022567935512558184471533035716554557378321289293120392294258731566673565
Gy = 74331715224220154299708533566163247663094029276428146274456519014761122295496
Kx=49293150360761418309411209621405185437426003792008480206387047056777011104939
Ky=43598371886286324285673726736628847559547403221353820773139325027318579443479
curve = ellipticcurve.CurveFp(p, a, b)
G= ellipticcurve.Point(curve, Gx, Gy)
K= ellipticcurve.Point(curve, Kx, Ky)
p1 = Kx^3 + a * Kx + b - Ky^2
p2 = Gx^3 + a * Gx + b - Gy^2
print(p1)
print(p2)
p=gcd(p1,p2)
print(p)

for i in range(1, 1000000):
    if i*G == K:
        print(i)
        break


# # 生成密钥对
# def generate_keys():
#     secret = SystemRandom().randrange(1, n)
#     public = secret * G
#     return secret, public

# # 加密
# def encrypt(M, public_key):
#     r = SystemRandom().randrange(1, n)
#     C1 = r * G
#     rP = r * public_key
#     M_point = ellipticcurve.Point(curve, M[0], M[1])
#     C2 = M_point + rP
#     return C1, C2

# # 解密
# def decrypt(C1, C2, secret):
#     rP = secret * C1
#     M_point = C2 - rP
#     return M_point.x(), M_point.y()

# # 示例
# secret, public = generate_keys()
# M = (1234567890, 987654321)  # 假设我们已经有一个点M
# C1, C2 = encrypt(M, public)
# decrypted_M = decrypt(C1, C2, secret)
# print("原始消息:", M)
# print("解密后的消息:", decrypted_M)