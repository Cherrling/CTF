# 初始谜题 2

## 使用 MD 长度扩展攻击

公开的 MD 攻击解释：

>这里不妨假设我们我们知道了 hash(key+s) 的 hash 值，其中 s 是已知的，那么其本身在计算的时候，必然会进行填充。那么我们首先可以得到 key+s 扩展后的字符串 now，即
>now=key|s|padding

>那么如果我们在 now 的后面再次附加上一部分信息extra，即
>key|s|padding|extra
>这样再去计算hash值的时候，会对 extra 进行填充直到满足条件。

>先计算 now 对应的链接变量 IV1，而我们已经知道这部分的 hash 值，并且链接变量产生 hash 值的算法是可逆的，所以我们可以得到链接变量。
>下面会根据得到的链接变量 IV1，对 extra 部分进行哈希算法，并返回hash值。
>那么既然我们已经知道了第一部分的 hash 值，并且，我们还知道 extra 的值，那么我们便可以得到最后的hash值。

>而之前我们也说了我们可以控制 message 的值。那么其实 s，padding，extra 我们都是可以控制的。所以我们自然可以找到对应的(message,x)满足x=hash(key|message)。

## 具体实现代码

通过加密的token找到链接向量
```python
hash1 = 0x571c0dcca05d5afc59c8de7a373adc25529e5fc240355765150317d7ca385b48
IV1=[]
for i in range (0,8):
    tmp=token[i*8:(i+1)*8]
    # print(int(tmp,16))
    IV1.append(int(tmp,16))
    
print(f"IV1={IV1}")
# IV1=[1461456332, 2690472700, 1506336378, 926604325, 1386110914, 1077237605, 352524247, 3392691016]
```

我们已知 hask_key 的长度，所以可以开始构造 padding 后的 block

```python
ori='000000000000000000000000000000000000000000000000000000000000000056fa775a80000000000000000000000000000000000000000000000000000120'

# 然后我们尝试在后面添加第二个 block
new_ori='000000000000000000000000000000000000000000000000000000000000000056fa775a80000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000056fa775b80000000000000000000000000000000000000000000000000000320'

```
由于我们已知 hask_key 长度，我们可以构造一个超长的 counter，使其正好符合 padding 的规则，同时满足 counter 的后八位大于题中给的 counter。
```python
counter='56fa775b80000000000000000000000000000000000000000000000000000320'

#计算第二个block
B=bytearray(bytes.fromhex(counter))

res=sm3.sm3_cf(IV1, B)

y = res
result = ""
for i in y:
    result = '%s%08x' % (result, i)
print(f"token={result}")

```
即获得伪造的 token
```
af18d3d5c48e246f87c19553a0fd8dd97981be1e419d0b182d9bff11a640f1a3
```