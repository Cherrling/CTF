# from Crypto.Util.number import *
# from sympy import isprime, nextprime,sqrt
# # from math import sqrt
# # 已知的 N 和 c
# N =  53484636256642371560557281621456529213886750698335089006224352215637420592873517734275862450163148392945951041483095064819220910317899992578165040990433940334036807721371326555512024039224109079099019828988874243601770836451859446230963865228408732101962008744705838775606012033438423945424042426734841615979
# c = 5579490288570939425542711404629218328055027204611319202398778444573780218548669221018717049011587214435072845769511800874652945546804271918716851109128729042921592450808078647004370046146837246417974216099426026724060199840863301288695043149861957452749925003438574499649330491058324598063395451093237166305
# e = 65537

# # 使用 sympy 计算 N 的大致平方根
# approx_p = int(sqrt(N))
# print(approx_p)

# # 向下找到第2^10个素数 p
# # for _ in range(2**10):  # 10位随机数意味着最多1024次 nextprime
# #     approx_p -= 1
# #     while not isprime(approx_p):
# #         approx_p -= 1
# #     print(_)  # 为了方便调试，打印当前尝试的次数
    
# approx_p = 7313319099878137868760948674456180386210897666727226476662181575496113664744279689373664711899414035086561316585488026160299473996709313419333733063499361

# # print(approx_p)

# # 从近似平方根开始尝试找到合适的 p 和 q
# def find_p_q(N, approx_p):
#     p_count=0
#     while True:
#         if N % approx_p == 0:
#             q = N // approx_p
#             return approx_p, q 
#         if p_count>2**10+100:
#             break
#         approx_p = nextprime(approx_p)  # 如果找不到，尝试下一个素数 p
#         p_count+=1
#         print("p_count:",p_count)


# p, q = find_p_q(N, approx_p)

# print("p: ", p)
# print("q:",q)

# # 找到 p 和 q 后，计算 phi 和私钥 d
# phi = (p - 1) * (q - 1)
# d = inverse(e, phi)

# # 解密得到原文 m
# m = pow(c, d, N)
# flag = long_to_bytes(m)
# print(flag.decode())



from sympy import isprime, nextprime, sqrt, Mod, div
from Crypto.Util.number import long_to_bytes, inverse

# 已知的 N 和 c
N = 53484636256642371560557281621456529213886750698335089006224352215637420592873517734275862450163148392945951041483095064819220910317899992578165040990433940334036807721371326555512024039224109079099019828988874243601770836451859446230963865228408732101962008744705838775606012033438423945424042426734841615979
c = 5579490288570939425542711404629218328055027204611319202398778444573780218548669221018717049011587214435072845769511800874652945546804271918716851109128729042921592450808078647004370046146837246417974216099426026724060199840863301288695043149861957452749925003438574499649330491058324598063395451093237166305
e = 65537

# 使用 sympy 计算 N 的大致平方根
approx_p = int(sqrt(N))
approx_p = 7313319099878137868760948674456180386210897666727226476662181575496113664744279689373664711899414035086561316585488026160299473996709313419333733063499361

print("Approximate p:", approx_p)

# 从近似平方根开始尝试找到合适的 p 和 q
def find_p_q(N, approx_p):
    p_count = 0
    while True:
        if Mod(N, approx_p) == 0:
            q, remainder = div(N, approx_p)
            if remainder == 0 and isprime(approx_p) and isprime(q):
                return approx_p, q
        if p_count > 2**10 + 100:
            break
        approx_p = nextprime(approx_p)  # 如果找不到，尝试下一个素数 p
        p_count += 1
        print("p_count:", p_count)

p, q = find_p_q(N, approx_p)

print("p:", p)
print("q:", q)

# 找到 p 和 q 后，计算 phi 和私钥 d
phi = (p - 1) * (q - 1)
d = inverse(e, phi)

# 解密得到原文 m
m = pow(c, d, N)
flag = long_to_bytes(m)
print(flag.decode())
